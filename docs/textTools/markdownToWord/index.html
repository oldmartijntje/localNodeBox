<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obsidian Markdown to DOCX Converter</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/8.5.0/docx.min.js"></script>
    <style>
        .callout {
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid;
            background-color: rgba(0, 0, 0, 0.05);
        }

        .callout.info {
            border-color: #0dcaf0;
            background-color: rgba(13, 202, 240, 0.1);
        }

        .callout.warning {
            border-color: #ffc107;
            background-color: rgba(255, 193, 7, 0.1);
        }

        .callout.note {
            border-color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
        }

        .tag {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background-color: #e9ecef;
            border-radius: 0.25rem;
            margin: 0.1rem;
            color: #495057;
        }

        .code-block {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }

        .link-placeholder {
            font-style: italic;
            color: #6c757d;
        }
    </style>
</head>

<body class="bg-light">
    <div class="container py-5">
        <div class="row justify-content-center">
            <div class="col-md-10">
                <div class="card shadow">
                    <div class="card-header bg-primary text-white">
                        <h3 class="mb-0">Obsidian Markdown to DOCX Converter</h3>
                    </div>
                    <div class="card-body">
                        <div class="mb-4">
                            <label for="mdFile" class="form-label">Choose an Obsidian Markdown file</label>
                            <input type="file" class="form-control" id="mdFile" accept=".md">
                        </div>
                        <div class="mb-4">
                            <label class="form-label">Preview:</label>
                            <div id="preview" class="border rounded p-3 bg-white" style="min-height: 200px;"></div>
                        </div>
                        <button id="convertBtn" class="btn btn-primary" disabled>
                            Convert to DOCX
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('mdFile');
        const preview = document.getElementById('preview');
        const convertBtn = document.getElementById('convertBtn');
        let markdownContent = '';

        // Custom renderer for Obsidian-specific features
        const renderer = new marked.Renderer();

        // Handle Obsidian checkboxes
        renderer.listitem = function (text) {
            if (text.includes('[ ]')) {
                return `<li style="list-style-type: none;">
                    <input type="checkbox" disabled> ${text.replace('[ ]', '')}
                </li>`;
            }
            if (text.includes('[x]')) {
                return `<li style="list-style-type: none;">
                    <input type="checkbox" checked disabled> ${text.replace('[x]', '')}
                </li>`;
            }
            return `<li>${text}</li>`;
        };

        // Process Obsidian-specific markdown features
        function processObsidianMarkdown(text) {
            // Handle callouts
            text = text.replace(
                />\[!(info|warning|note)\]-?\s*\n>(.*?)(?=\n\n|\n(?!>)|$)/gs,
                (match, type, content) => {
                    return `<div class="callout ${type.toLowerCase()}">${content.trim()}</div>`;
                }
            );

            // Handle hashtags
            text = text.replace(
                /#(\w+)/g,
                '<span class="tag">#$1</span>'
            );

            // Handle code blocks
            text = text.replace(
                /```(\w*)\n([\s\S]*?)```/g,
                '<div class="code-block">$2</div>'
            );

            // Handle embedded content
            text = text.replace(
                /!\[(.+?)\]\((.+?)\)/g,
                '<div class="link-placeholder">Embedded content: $1</div>'
            );

            // Handle math equations
            text = text.replace(
                /\$\$(.*?)\$\$/g,
                '<div class="link-placeholder">Math equation: $1</div>'
            );

            // Handle footnotes
            text = text.replace(
                /\[\^(.*?)\]/g,
                '<div class="link-placeholder">Footnote: $1</div>'
            );

            // Handle internal links (formatted as placeholders)
            text = text.replace(
                /\[\[(.*?)\]\]/g,
                '<div class="link-placeholder">[Internal link: $1]</div>'
            );

            return text;
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            markdownContent = await file.text();

            // Process Obsidian markdown features before rendering
            const processedContent = processObsidianMarkdown(markdownContent);

            // Set marked options
            marked.setOptions({
                renderer: renderer,
                breaks: true,
                gfm: true
            });

            preview.innerHTML = marked.parse(processedContent);
            convertBtn.disabled = false;
        });

        // Convert markdown to DOCX paragraphs
        function markdownToDocxParagraphs(markdown) {
            const paragraphs = [];

            // Handle callouts
            const calloutRegex = />\[!(info|warning|note)\]-?\s*\n>(.*?)(?=\n\n|\n(?!>)|$)/gs;
            markdown = markdown.replace(calloutRegex, (match, type, content) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: `[${type.toUpperCase()}] ${content.trim()}`,
                                bold: true
                            })
                        ],
                        spacing: { before: 200, after: 200 }
                    })
                );
                return '';
            });

            // Handle checkboxes
            markdown = markdown.replace(/- \[(x| )\] (.*)/g, (match, checked, text) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: `${checked === 'x' ? '☒' : '☐'} ${text}`,
                            })
                        ],
                        spacing: { before: 100, after: 100 }
                    })
                );
                return '';
            });

            // Handle code blocks
            markdown = markdown.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: code.trim(),
                                font: 'Courier New'
                            })
                        ],
                        spacing: { before: 200, after: 200 }
                    })
                );
                return '';
            });

            // Handle hashtags
            markdown = markdown.replace(/#(\w+)/g, (match, tag) => {
                return `[TAG: ${tag}]`;
            });

            // Handle embedded content
            markdown = markdown.replace(/!\[(.+?)\]\((.+?)\)/g, (match, alt, src) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: `[Embedded content: ${alt}]`
                            })
                        ],
                        spacing: { before: 200, after: 200 }
                    })
                );
                return '';
            });

            // Handle math equations
            markdown = markdown.replace(/\$\$(.*?)\$\$/g, (match, equation) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: `[Math equation: ${equation}]`
                            })
                        ],
                        spacing: { before: 200, after: 200 }
                    })
                );
                return '';
            });

            // Handle footnotes
            markdown = markdown.replace(/\[\^(.*?)\]/g, (match, footnote) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: `[Footnote: ${footnote}]`
                            })
                        ],
                        spacing: { before: 100, after: 100 }
                    })
                );
                return '';
            });

            // Handle internal links (formatted as placeholders)
            markdown = markdown.replace(/\[\[(.*?)\]\]/g, (match, link) => {
                paragraphs.push(
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun({
                                text: `[Internal link: ${link}]`,
                                italics: true,
                                color: '#6c757d'
                            })
                        ],
                        spacing: { before: 100, after: 100 }
                    })
                );
                return '';
            });

            // Add remaining content
            const lines = markdown.split('\n');
            lines.forEach(line => {
                if (line.trim()) {
                    paragraphs.push(
                        new docx.Paragraph({
                            children: [
                                new docx.TextRun({
                                    text: line
                                })
                            ]
                        })
                    );
                }
            });

            return paragraphs;
        }

        convertBtn.addEventListener('click', async () => {
            const paragraphs = markdownToDocxParagraphs(markdownContent);

            const doc = new docx.Document({
                sections: [{
                    properties: {},
                    children: paragraphs
                }]
            });

            // Generate the document
            const blob = await docx.Packer.toBlob(doc);

            // Create download link
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'obsidian-converted.docx';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        });
    </script>
</body>

</html>