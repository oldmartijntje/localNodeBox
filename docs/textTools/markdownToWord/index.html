<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obsidian Markdown to DOCX Converter</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <script src="https://unpkg.com/docx@7.1.0/build/index.js"></script>
    <style>
        .callout {
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid;
            background-color: rgba(0, 0, 0, 0.05);
        }

        .callout.info {
            border-color: #0dcaf0;
            background-color: rgba(13, 202, 240, 0.1);
        }

        .callout.warning {
            border-color: #ffc107;
            background-color: rgba(255, 193, 7, 0.1);
        }

        .callout.note {
            border-color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
        }

        .tag {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background-color: #e9ecef;
            border-radius: 0.25rem;
            margin: 0.1rem;
            color: #495057;
        }

        .code-block {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }

        .link-placeholder {
            font-style: italic;
            color: #6c757d;
        }
    </style>
</head>

<body class="bg-light">
    <div class="container py-5">
        <div class="row justify-content-center">
            <div class="col-md-10">
                <div class="card shadow">
                    <div class="card-header bg-primary text-white">
                        <h3 class="mb-0">Obsidian Markdown to DOCX Converter</h3>
                    </div>
                    <div class="card-body">
                        <div class="mb-4">
                            <label for="mdFile" class="form-label">Choose an Obsidian Markdown file</label>
                            <input type="file" class="form-control" id="mdFile" accept=".md">
                        </div>
                        <div class="mb-4">
                            <label class="form-label">Preview:</label>
                            <div id="preview" class="border rounded p-3 bg-white" style="min-height: 200px;"></div>
                        </div>
                        <button id="convertBtn" class="btn btn-primary" disabled>
                            Convert to DOCX
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { Document, Paragraph, TextRun, Packer, HeadingLevel, ExternalHyperlink } = window.docx;
        const fileInput = document.getElementById('mdFile');
        const preview = document.getElementById('preview');
        const convertBtn = document.getElementById('convertBtn');
        let markdownContent = '';

        // Custom renderer for Obsidian-specific features
        const renderer = new marked.Renderer();

        // Handle headers in preview
        renderer.heading = function (text, level) {
            return `<h${level}>${text}</h${level}>`;
        };

        // Handle links in preview
        renderer.link = function (href, title, text) {
            return `<a href="${href}" ${title ? `title="${title}"` : ''}>${text}</a>`;
        };

        // Handle Obsidian checkboxes
        renderer.listitem = function (text) {
            if (text.includes('[ ]')) {
                return `<li style="list-style-type: none;">
                    <input type="checkbox" disabled> ${text.replace('[ ]', '')}
                </li>`;
            }
            if (text.includes('[x]')) {
                return `<li style="list-style-type: none;">
                    <input type="checkbox" checked disabled> ${text.replace('[x]', '')}
                </li>`;
            }
            return `<li>${text}</li>`;
        };

        // Process Obsidian-specific markdown features
        function processObsidianMarkdown(text) {
            // Handle callouts
            text = text.replace(
                />\[!(info|warning|note)\]-?\s*\n>(.*?)(?=\n\n|\n(?!>)|$)/gs,
                (match, type, content) => {
                    return `<div class="callout ${type.toLowerCase()}">${content.trim()}</div>`;
                }
            );

            // Handle code blocks
            text = text.replace(
                /```(\w*)\n([\s\S]*?)```/g,
                '<div class="code-block">$2</div>'
            );

            // Handle embedded content
            text = text.replace(
                /!\[(.+?)\]\((.+?)\)/g,
                '<div class="link-placeholder">Embedded content: $1</div>'
            );

            // Handle math equations
            text = text.replace(
                /\$\$(.*?)\$\$/g,
                '<div class="link-placeholder">Math equation: $1</div>'
            );

            // Handle footnotes
            text = text.replace(
                /\[\^(.*?)\]/g,
                '<div class="link-placeholder">Footnote: $1</div>'
            );

            // Handle internal links (formatted as placeholders)
            text = text.replace(
                /\[\[(.*?)\]\]/g,
                '<div class="link-placeholder">[Internal link: $1]</div>'
            );

            return text;
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            markdownContent = await file.text();

            // Process Obsidian markdown features before rendering
            const processedContent = processObsidianMarkdown(markdownContent);

            // Set marked options
            marked.setOptions({
                renderer: renderer,
                breaks: true,
                gfm: true
            });

            preview.innerHTML = marked.parse(processedContent);
            convertBtn.disabled = false;
        });

        // Convert markdown to DOCX paragraphs
        function markdownToDocxParagraphs(markdown) {
            const paragraphs = [];

            // Handle headers
            const headerRegex = /^(#{1,6})\s+(.+)$/gm;
            markdown = markdown.replace(headerRegex, (match, hashes, text) => {
                const level = hashes.length;
                paragraphs.push(
                    new Paragraph({
                        text: text.trim(),
                        heading: {
                            level: level === 1 ? HeadingLevel.HEADING_1 :
                                level === 2 ? HeadingLevel.HEADING_2 :
                                    level === 3 ? HeadingLevel.HEADING_3 :
                                        level === 4 ? HeadingLevel.HEADING_4 :
                                            level === 5 ? HeadingLevel.HEADING_5 :
                                                HeadingLevel.HEADING_6
                        },
                        spacing: { before: 200, after: 200 }
                    })
                );
                return '';
            });

            // Handle external links
            const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
            markdown = markdown.replace(linkRegex, (match, text, url) => {
                paragraphs.push(
                    new Paragraph({
                        children: [
                            new ExternalHyperlink({
                                children: [
                                    new TextRun({
                                        text: text,
                                        style: "Hyperlink"
                                    })
                                ],
                                link: url
                            })
                        ]
                    })
                );
                return '';
            });

            // Previous Obsidian-specific conversions remain the same

            // Handle remaining content with inline formatting
            const lines = markdown.split('\n');
            lines.forEach(line => {
                if (line.trim()) {
                    // Handle basic inline formatting
                    const children = [];
                    let currentText = line;

                    // Bold
                    currentText = currentText.replace(/\*\*(.*?)\*\*/g, (match, text) => {
                        children.push(new TextRun({ text, bold: true }));
                        return '';
                    });

                    // Italic
                    currentText = currentText.replace(/\*(.*?)\*/g, (match, text) => {
                        children.push(new TextRun({ text, italics: true }));
                        return '';
                    });

                    // Add remaining text
                    if (currentText.trim()) {
                        children.push(new TextRun(currentText));
                    }

                    if (children.length > 0) {
                        paragraphs.push(new Paragraph({ children }));
                    }
                }
            });

            return paragraphs;
        }

        convertBtn.addEventListener('click', async () => {
            const paragraphs = markdownToDocxParagraphs(markdownContent);

            const doc = new Document({
                sections: [{
                    properties: {},
                    children: paragraphs
                }]
            });

            // Generate the document
            const blob = await Packer.toBlob(doc);

            // Create download link
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'obsidian-converted.docx';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        });
    </script>
</body>

</html>